# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.10

import enum
import datetime
import sys
import types
import typing

import winsdk.system
import winsdk.windows.applicationmodel.core
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.graphics.imaging
import winsdk.windows.storage.streams
import winsdk.windows.ui
import winsdk.windows.ui.startscreen

class SecurityAppKind(enum.IntEnum):
    WEB_PROTECTION = 0

class SecurityAppState(enum.IntEnum):
    DISABLED = 0
    ENABLED = 1

class SecurityAppSubstatus(enum.IntEnum):
    UNDETERMINED = 0
    NO_ACTION_NEEDED = 1
    ACTION_RECOMMENDED = 2
    ACTION_NEEDED = 3

class ShareWindowCommand(enum.IntEnum):
    NONE = 0
    START_SHARING = 1
    STOP_SHARING = 2

Self = typing.TypeVar('Self')

class AdaptiveCardBuilder(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> AdaptiveCardBuilder: ...
    @staticmethod
    def create_adaptive_card_from_json(value: str, /) -> typing.Optional[IAdaptiveCard]: ...

class FocusSession(winsdk.system.Object):
    id: str
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> FocusSession: ...
    def end(self) -> None: ...

class FocusSessionManager(winsdk.system.Object):
    is_focus_active: winsdk.system.Boolean
    is_supported: typing.ClassVar[winsdk.system.Boolean]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> FocusSessionManager: ...
    def deactivate_focus(self) -> None: ...
    @staticmethod
    def get_default() -> typing.Optional[FocusSessionManager]: ...
    def get_session(self, id: str, /) -> typing.Optional[FocusSession]: ...
    @typing.overload
    def try_start_focus_session(self) -> typing.Optional[FocusSession]: ...
    @typing.overload
    def try_start_focus_session(self, end_time: datetime.datetime, /) -> typing.Optional[FocusSession]: ...
    def add_is_focus_active_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[FocusSessionManager, winsdk.system.Object], /) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_is_focus_active_changed(self, token: winsdk.windows.foundation.EventRegistrationToken, /) -> None: ...

class SecurityAppManager(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> SecurityAppManager: ...
    def __new__(cls: typing.Type[SecurityAppManager]) -> SecurityAppManager:...
    def register(self, kind: SecurityAppKind, display_name: str, details_uri: typing.Optional[winsdk.windows.foundation.Uri], register_per_user: winsdk.system.Boolean, /) -> winsdk.system.Guid: ...
    def unregister(self, kind: SecurityAppKind, guid_registration: winsdk.system.Guid, /) -> None: ...
    def update_state(self, kind: SecurityAppKind, guid_registration: winsdk.system.Guid, state: SecurityAppState, substatus: SecurityAppSubstatus, details_uri: typing.Optional[winsdk.windows.foundation.Uri], /) -> None: ...

class ShareWindowCommandEventArgs(winsdk.system.Object):
    command: ShareWindowCommand
    window_id: winsdk.windows.ui.WindowId
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> ShareWindowCommandEventArgs: ...

class ShareWindowCommandSource(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> ShareWindowCommandSource: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[ShareWindowCommandSource]: ...
    def report_command_changed(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_command_invoked(self, handler: winsdk.windows.foundation.TypedEventHandler[ShareWindowCommandSource, ShareWindowCommandEventArgs], /) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_command_invoked(self, token: winsdk.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_command_requested(self, handler: winsdk.windows.foundation.TypedEventHandler[ShareWindowCommandSource, ShareWindowCommandEventArgs], /) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_command_requested(self, token: winsdk.windows.foundation.EventRegistrationToken, /) -> None: ...

class TaskbarManager(winsdk.system.Object):
    is_pinning_allowed: winsdk.system.Boolean
    is_supported: winsdk.system.Boolean
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> TaskbarManager: ...
    @staticmethod
    def get_default() -> typing.Optional[TaskbarManager]: ...
    def is_app_list_entry_pinned_async(self, app_list_entry: typing.Optional[winsdk.windows.applicationmodel.core.AppListEntry], /) -> winsdk.windows.foundation.IAsyncOperation[winsdk.system.Boolean]: ...
    def is_current_app_pinned_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.system.Boolean]: ...
    def is_secondary_tile_pinned_async(self, tile_id: str, /) -> winsdk.windows.foundation.IAsyncOperation[winsdk.system.Boolean]: ...
    def request_pin_app_list_entry_async(self, app_list_entry: typing.Optional[winsdk.windows.applicationmodel.core.AppListEntry], /) -> winsdk.windows.foundation.IAsyncOperation[winsdk.system.Boolean]: ...
    def request_pin_current_app_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.system.Boolean]: ...
    def request_pin_secondary_tile_async(self, secondary_tile: typing.Optional[winsdk.windows.ui.startscreen.SecondaryTile], /) -> winsdk.windows.foundation.IAsyncOperation[winsdk.system.Boolean]: ...
    def try_unpin_secondary_tile_async(self, tile_id: str, /) -> winsdk.windows.foundation.IAsyncOperation[winsdk.system.Boolean]: ...

class WindowTab(winsdk.system.Object):
    treat_as_secondary_tile_id: str
    title: str
    tag: typing.Optional[winsdk.system.Object]
    icon: typing.Optional[WindowTabIcon]
    group: typing.Optional[WindowTabGroup]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTab: ...
    def __new__(cls: typing.Type[WindowTab]) -> WindowTab:...
    def report_thumbnail_available(self) -> None: ...

class WindowTabCloseRequestedEventArgs(winsdk.system.Object):
    tab: typing.Optional[WindowTab]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTabCloseRequestedEventArgs: ...

class WindowTabCollection(winsdk.system.Object, typing.MutableSequence[WindowTab]):
    size: winsdk.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> WindowTab: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winsdk.system.Array[WindowTab]: ...
    def insert(self, index: int, value: WindowTab) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: WindowTab) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[WindowTab]) -> None: ...
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTabCollection: ...
    def append(self, value: typing.Optional[WindowTab], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[WindowTab]]: ...
    def get_at(self, index: winsdk.system.UInt32, /) -> typing.Optional[WindowTab]: ...
    def get_many(self, start_index: winsdk.system.UInt32, items: winsdk.system.Array[WindowTab], /) -> winsdk.system.UInt32: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[WindowTab]]: ...
    def index_of(self, value: typing.Optional[WindowTab], /) -> typing.Tuple[winsdk.system.Boolean, winsdk.system.UInt32]: ...
    def insert_at(self, index: winsdk.system.UInt32, value: typing.Optional[WindowTab], /) -> None: ...
    def move_tab(self, tab: typing.Optional[WindowTab], index: winsdk.system.UInt32, /) -> None: ...
    def remove_at(self, index: winsdk.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winsdk.system.Array[WindowTab], /) -> None: ...
    def set_at(self, index: winsdk.system.UInt32, value: typing.Optional[WindowTab], /) -> None: ...

class WindowTabGroup(winsdk.system.Object):
    title: str
    icon: typing.Optional[WindowTabIcon]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTabGroup: ...
    def __new__(cls: typing.Type[WindowTabGroup]) -> WindowTabGroup:...

class WindowTabIcon(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTabIcon: ...
    @typing.overload
    @staticmethod
    def create_from_font_glyph(glyph: str, font_family: str, /) -> typing.Optional[WindowTabIcon]: ...
    @typing.overload
    @staticmethod
    def create_from_font_glyph(glyph: str, font_family: str, font_uri: typing.Optional[winsdk.windows.foundation.Uri], /) -> typing.Optional[WindowTabIcon]: ...
    @staticmethod
    def create_from_image(image: typing.Optional[winsdk.windows.storage.streams.IRandomAccessStreamReference], /) -> typing.Optional[WindowTabIcon]: ...

class WindowTabManager(winsdk.system.Object):
    tabs: typing.Optional[WindowTabCollection]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTabManager: ...
    @staticmethod
    def get_for_window(id: winsdk.windows.ui.WindowId, /) -> typing.Optional[WindowTabManager]: ...
    @staticmethod
    def is_supported() -> winsdk.system.Boolean: ...
    @staticmethod
    def is_tab_tear_out_supported() -> winsdk.system.Boolean: ...
    def set_active_tab(self, tab: typing.Optional[WindowTab], /) -> None: ...
    def add_tab_close_requested(self, handler: winsdk.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabCloseRequestedEventArgs], /) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_tab_close_requested(self, token: winsdk.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_switch_requested(self, handler: winsdk.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabSwitchRequestedEventArgs], /) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_tab_switch_requested(self, token: winsdk.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_tear_out_requested(self, handler: winsdk.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabTearOutRequestedEventArgs], /) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_tab_tear_out_requested(self, token: winsdk.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_thumbnail_requested(self, handler: winsdk.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabThumbnailRequestedEventArgs], /) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_tab_thumbnail_requested(self, token: winsdk.windows.foundation.EventRegistrationToken, /) -> None: ...

class WindowTabSwitchRequestedEventArgs(winsdk.system.Object):
    tab: typing.Optional[WindowTab]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTabSwitchRequestedEventArgs: ...

class WindowTabTearOutRequestedEventArgs(winsdk.system.Object):
    window_id: winsdk.system.UInt64
    tab: typing.Optional[WindowTab]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTabTearOutRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winsdk.windows.foundation.Deferral]: ...

class WindowTabThumbnailRequestedEventArgs(winsdk.system.Object):
    image: typing.Optional[winsdk.windows.storage.streams.IRandomAccessStreamReference]
    is_composited_on_window: winsdk.system.Boolean
    requested_size: winsdk.windows.graphics.imaging.BitmapSize
    tab: typing.Optional[WindowTab]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> WindowTabThumbnailRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winsdk.windows.foundation.Deferral]: ...

class IAdaptiveCard(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> IAdaptiveCard: ...
    def to_json(self) -> str: ...

class IAdaptiveCardBuilderStatics(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> IAdaptiveCardBuilderStatics: ...
    def create_adaptive_card_from_json(self, value: str, /) -> typing.Optional[IAdaptiveCard]: ...

