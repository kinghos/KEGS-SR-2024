# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.10

import enum
import datetime
import sys
import types
import typing

import winsdk.system
import winsdk.windows.applicationmodel
import winsdk.windows.foundation
import winsdk.windows.foundation.collections

class AddPackageByAppInstallerOptions(enum.IntFlag):
    NONE = 0
    INSTALL_ALL_RESOURCES = 0x20
    FORCE_TARGET_APP_SHUTDOWN = 0x40
    REQUIRED_CONTENT_GROUP_ONLY = 0x100
    LIMIT_TO_EXISTING_PACKAGES = 0x200

class DeploymentOptions(enum.IntFlag):
    NONE = 0
    FORCE_APPLICATION_SHUTDOWN = 0x1
    DEVELOPMENT_MODE = 0x2
    INSTALL_ALL_RESOURCES = 0x20
    FORCE_TARGET_APPLICATION_SHUTDOWN = 0x40
    REQUIRED_CONTENT_GROUP_ONLY = 0x100
    FORCE_UPDATE_FROM_ANY_VERSION = 0x40000
    RETAIN_FILES_ON_FAILURE = 0x200000
    STAGE_IN_PLACE = 0x400000

class DeploymentProgressState(enum.IntEnum):
    QUEUED = 0
    PROCESSING = 1

class PackageInstallState(enum.IntEnum):
    NOT_INSTALLED = 0
    STAGED = 1
    INSTALLED = 2
    PAUSED = 6

class PackageState(enum.IntEnum):
    NORMAL = 0
    LICENSE_INVALID = 1
    MODIFIED = 2
    TAMPERED = 3

class PackageStatus(enum.IntFlag):
    O_K = 0
    LICENSE_ISSUE = 0x1
    MODIFIED = 0x2
    TAMPERED = 0x4
    DISABLED = 0x8

class PackageStubPreference(enum.IntEnum):
    FULL = 0
    STUB = 1

class PackageTypes(enum.IntFlag):
    NONE = 0
    MAIN = 0x1
    FRAMEWORK = 0x2
    RESOURCE = 0x4
    BUNDLE = 0x8
    XAP = 0x10
    OPTIONAL = 0x20
    ALL = 0xffffffff

class RemovalOptions(enum.IntFlag):
    NONE = 0
    PRESERVE_APPLICATION_DATA = 0x1000
    PRESERVE_ROAMABLE_APPLICATION_DATA = 0x80
    REMOVE_FOR_ALL_USERS = 0x80000

class SharedPackageContainerCreationCollisionOptions(enum.IntEnum):
    FAIL_IF_EXISTS = 0
    MERGE_WITH_EXISTING = 1
    REPLACE_EXISTING = 2

class SharedPackageContainerOperationStatus(enum.IntEnum):
    SUCCESS = 0
    BLOCKED_BY_POLICY = 1
    ALREADY_EXISTS = 2
    PACKAGE_FAMILY_EXISTS_IN_ANOTHER_CONTAINER = 3
    NOT_FOUND = 4
    UNKNOWN_FAILURE = 5

class StubPackageOption(enum.IntEnum):
    DEFAULT = 0
    INSTALL_FULL = 1
    INSTALL_STUB = 2
    USE_PREFERENCE = 3

Self = typing.TypeVar('Self')

class DeploymentProgress:
    state: DeploymentProgressState
    percentage: winsdk.system.UInt32
    def __new__(cls: typing.Type[DeploymentProgress], state: DeploymentProgressState, percentage: winsdk.system.UInt32) -> DeploymentProgress: ...

class AddPackageOptions(winsdk.system.Object):
    target_volume: typing.Optional[PackageVolume]
    stub_package_option: StubPackageOption
    stage_in_place: winsdk.system.Boolean
    retain_files_on_failure: winsdk.system.Boolean
    required_content_group_only: winsdk.system.Boolean
    install_all_resources: winsdk.system.Boolean
    force_update_from_any_version: winsdk.system.Boolean
    force_target_app_shutdown: winsdk.system.Boolean
    force_app_shutdown: winsdk.system.Boolean
    external_location_uri: typing.Optional[winsdk.windows.foundation.Uri]
    developer_mode: winsdk.system.Boolean
    defer_registration_when_packages_are_in_use: winsdk.system.Boolean
    allow_unsigned: winsdk.system.Boolean
    dependency_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    optional_package_family_names: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    optional_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    related_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    limit_to_existing_packages: winsdk.system.Boolean
    expected_digests: typing.Optional[winsdk.windows.foundation.collections.IMap[winsdk.windows.foundation.Uri, str]]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> AddPackageOptions: ...
    def __new__(cls: typing.Type[AddPackageOptions]) -> AddPackageOptions:...

class AppInstallerManager(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> AppInstallerManager: ...
    def clear_auto_update_settings(self, package_family_name: str, /) -> None: ...
    @staticmethod
    def get_default() -> typing.Optional[AppInstallerManager]: ...
    @staticmethod
    def get_for_system() -> typing.Optional[AppInstallerManager]: ...
    def pause_auto_updates_until(self, package_family_name: str, date_time: datetime.datetime, /) -> None: ...
    def set_auto_update_settings(self, package_family_name: str, app_installer_info: typing.Optional[AutoUpdateSettingsOptions], /) -> None: ...

class AutoUpdateSettingsOptions(winsdk.system.Object):
    version: winsdk.windows.applicationmodel.PackageVersion
    update_blocks_activation: winsdk.system.Boolean
    show_prompt: winsdk.system.Boolean
    on_launch: winsdk.system.Boolean
    is_auto_repair_enabled: winsdk.system.Boolean
    hours_between_update_checks: winsdk.system.UInt32
    force_update_from_any_version: winsdk.system.Boolean
    automatic_background_task: winsdk.system.Boolean
    app_installer_uri: typing.Optional[winsdk.windows.foundation.Uri]
    dependency_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    optional_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    repair_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    update_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> AutoUpdateSettingsOptions: ...
    def __new__(cls: typing.Type[AutoUpdateSettingsOptions]) -> AutoUpdateSettingsOptions:...
    @staticmethod
    def create_from_app_installer_info(app_installer_info: typing.Optional[winsdk.windows.applicationmodel.AppInstallerInfo], /) -> typing.Optional[AutoUpdateSettingsOptions]: ...

class CreateSharedPackageContainerOptions(winsdk.system.Object):
    force_app_shutdown: winsdk.system.Boolean
    create_collision_option: SharedPackageContainerCreationCollisionOptions
    members: typing.Optional[winsdk.windows.foundation.collections.IVector[SharedPackageContainerMember]]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> CreateSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[CreateSharedPackageContainerOptions]) -> CreateSharedPackageContainerOptions:...

class CreateSharedPackageContainerResult(winsdk.system.Object):
    container: typing.Optional[SharedPackageContainer]
    extended_error: winsdk.windows.foundation.HResult
    status: SharedPackageContainerOperationStatus
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> CreateSharedPackageContainerResult: ...

class DeleteSharedPackageContainerOptions(winsdk.system.Object):
    force_app_shutdown: winsdk.system.Boolean
    all_users: winsdk.system.Boolean
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> DeleteSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[DeleteSharedPackageContainerOptions]) -> DeleteSharedPackageContainerOptions:...

class DeleteSharedPackageContainerResult(winsdk.system.Object):
    extended_error: winsdk.windows.foundation.HResult
    status: SharedPackageContainerOperationStatus
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> DeleteSharedPackageContainerResult: ...

class DeploymentResult(winsdk.system.Object):
    activity_id: winsdk.system.Guid
    error_text: str
    extended_error_code: winsdk.windows.foundation.HResult
    is_registered: winsdk.system.Boolean
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> DeploymentResult: ...

class FindSharedPackageContainerOptions(winsdk.system.Object):
    package_family_name: str
    name: str
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> FindSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[FindSharedPackageContainerOptions]) -> FindSharedPackageContainerOptions:...

class PackageAllUserProvisioningOptions(winsdk.system.Object):
    optional_package_family_names: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    projection_order_package_family_names: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> PackageAllUserProvisioningOptions: ...
    def __new__(cls: typing.Type[PackageAllUserProvisioningOptions]) -> PackageAllUserProvisioningOptions:...

class PackageManager(winsdk.system.Object):
    debug_settings: typing.Optional[PackageManagerDebugSettings]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> PackageManager: ...
    def __new__(cls: typing.Type[PackageManager]) -> PackageManager:...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], external_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], package_uris_to_install: typing.Iterable[winsdk.windows.foundation.Uri], related_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_by_app_installer_file_async(self, app_installer_file_uri: typing.Optional[winsdk.windows.foundation.Uri], options: AddPackageByAppInstallerOptions, target_volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_by_uri_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], options: typing.Optional[AddPackageOptions], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_volume_async(self, package_store_path: str, /) -> winsdk.windows.foundation.IAsyncOperation[PackageVolume]: ...
    def cleanup_package_for_user_async(self, package_name: str, user_security_id: str, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def clear_package_status(self, package_full_name: str, status: PackageStatus, /) -> None: ...
    def deprovision_package_for_all_users_async(self, package_family_name: str, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def find_package(self, package_full_name: str, /) -> typing.Optional[winsdk.windows.applicationmodel.Package]: ...
    def find_package_for_user(self, user_security_id: str, package_full_name: str, /) -> typing.Optional[winsdk.windows.applicationmodel.Package]: ...
    def find_package_volume(self, volume_name: str, /) -> typing.Optional[PackageVolume]: ...
    def find_package_volumes(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[PackageVolume]]: ...
    @typing.overload
    def find_packages(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_family_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_name: str, package_publisher: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_family_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_name: str, package_publisher: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_family_name: str, package_types: PackageTypes, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_name: str, package_publisher: str, package_types: PackageTypes, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_family_name: str, package_types: PackageTypes, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_name: str, package_publisher: str, package_types: PackageTypes, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[winsdk.windows.applicationmodel.Package]]: ...
    def find_provisioned_packages(self) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    def find_users(self, package_full_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IIterable[PackageUserInformation]]: ...
    def get_default_package_volume(self) -> typing.Optional[PackageVolume]: ...
    def get_package_stub_preference(self, package_family_name: str, /) -> PackageStubPreference: ...
    def get_package_volumes_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[PackageVolume]]: ...
    def move_package_to_volume_async(self, package_full_name: str, deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def provision_package_for_all_users_async(self, package_family_name: str, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def provision_package_for_all_users_async(self, main_package_family_name: str, options: typing.Optional[PackageAllUserProvisioningOptions], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def register_package_async(self, manifest_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def register_package_async(self, manifest_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, app_data_volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_family_name_async(self, main_package_family_name: str, dependency_package_family_names: typing.Iterable[str], deployment_options: DeploymentOptions, app_data_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_full_name_async(self, main_package_full_name: str, dependency_package_full_names: typing.Iterable[str], deployment_options: DeploymentOptions, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_uri_async(self, manifest_uri: typing.Optional[winsdk.windows.foundation.Uri], options: typing.Optional[RegisterPackageOptions], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_packages_by_full_name_async(self, package_full_names: typing.Iterable[str], options: typing.Optional[RegisterPackageOptions], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def remove_package_async(self, package_full_name: str, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def remove_package_async(self, package_full_name: str, removal_options: RemovalOptions, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def remove_package_volume_async(self, volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def request_add_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], related_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def request_add_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], related_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], package_uris_to_install: typing.Iterable[winsdk.windows.foundation.Uri], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def request_add_package_by_app_installer_file_async(self, app_installer_file_uri: typing.Optional[winsdk.windows.foundation.Uri], options: AddPackageByAppInstallerOptions, target_volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def set_default_package_volume(self, volume: typing.Optional[PackageVolume], /) -> None: ...
    def set_package_state(self, package_full_name: str, package_state: PackageState, /) -> None: ...
    def set_package_status(self, package_full_name: str, status: PackageStatus, /) -> None: ...
    def set_package_stub_preference(self, package_family_name: str, use_stub: PackageStubPreference, /) -> None: ...
    def set_package_volume_offline_async(self, package_volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def set_package_volume_online_async(self, package_volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], external_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], package_uris_to_install: typing.Iterable[winsdk.windows.foundation.Uri], related_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def stage_package_by_uri_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], options: typing.Optional[StagePackageOptions], /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_user_data_async(self, package_full_name: str, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_user_data_async(self, package_full_name: str, deployment_options: DeploymentOptions, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def update_package_async(self, package_uri: typing.Optional[winsdk.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winsdk.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winsdk.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...

class PackageManagerDebugSettings(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> PackageManagerDebugSettings: ...
    @typing.overload
    def set_content_group_state_async(self, package: typing.Optional[winsdk.windows.applicationmodel.Package], content_group_name: str, state: winsdk.windows.applicationmodel.PackageContentGroupState, /) -> winsdk.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_content_group_state_async(self, package: typing.Optional[winsdk.windows.applicationmodel.Package], content_group_name: str, state: winsdk.windows.applicationmodel.PackageContentGroupState, completion_percentage: winsdk.system.Double, /) -> winsdk.windows.foundation.IAsyncAction: ...

class PackageUserInformation(winsdk.system.Object):
    install_state: PackageInstallState
    user_security_id: str
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> PackageUserInformation: ...

class PackageVolume(winsdk.system.Object):
    is_offline: winsdk.system.Boolean
    is_system_volume: winsdk.system.Boolean
    mount_point: str
    name: str
    package_store_path: str
    supports_hard_links: winsdk.system.Boolean
    is_appx_install_supported: winsdk.system.Boolean
    is_full_trust_package_supported: winsdk.system.Boolean
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> PackageVolume: ...
    def find_package(self, package_full_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    def find_package_for_user(self, user_security_id: str, package_full_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_family_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_name: str, package_publisher: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_family_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_name: str, package_publisher: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, package_family_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, package_name: str, package_publisher: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, package_family_name: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, package_name: str, package_publisher: str, /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.applicationmodel.Package]]: ...
    def get_available_space_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.system.UInt64]: ...

class RegisterPackageOptions(winsdk.system.Object):
    stage_in_place: winsdk.system.Boolean
    install_all_resources: winsdk.system.Boolean
    force_update_from_any_version: winsdk.system.Boolean
    force_target_app_shutdown: winsdk.system.Boolean
    force_app_shutdown: winsdk.system.Boolean
    external_location_uri: typing.Optional[winsdk.windows.foundation.Uri]
    developer_mode: winsdk.system.Boolean
    defer_registration_when_packages_are_in_use: winsdk.system.Boolean
    app_data_volume: typing.Optional[PackageVolume]
    allow_unsigned: winsdk.system.Boolean
    dependency_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    optional_package_family_names: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    expected_digests: typing.Optional[winsdk.windows.foundation.collections.IMap[winsdk.windows.foundation.Uri, str]]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> RegisterPackageOptions: ...
    def __new__(cls: typing.Type[RegisterPackageOptions]) -> RegisterPackageOptions:...

class SharedPackageContainer(winsdk.system.Object):
    id: str
    name: str
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> SharedPackageContainer: ...
    def get_members(self) -> typing.Optional[winsdk.windows.foundation.collections.IVector[SharedPackageContainerMember]]: ...
    def remove_package_family(self, package_family_name: str, options: typing.Optional[UpdateSharedPackageContainerOptions], /) -> typing.Optional[UpdateSharedPackageContainerResult]: ...
    def reset_data(self) -> typing.Optional[UpdateSharedPackageContainerResult]: ...

class SharedPackageContainerManager(winsdk.system.Object):
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> SharedPackageContainerManager: ...
    def create_container(self, name: str, options: typing.Optional[CreateSharedPackageContainerOptions], /) -> typing.Optional[CreateSharedPackageContainerResult]: ...
    def delete_container(self, id: str, options: typing.Optional[DeleteSharedPackageContainerOptions], /) -> typing.Optional[DeleteSharedPackageContainerResult]: ...
    @typing.overload
    def find_containers(self) -> typing.Optional[winsdk.windows.foundation.collections.IVector[SharedPackageContainer]]: ...
    @typing.overload
    def find_containers(self, options: typing.Optional[FindSharedPackageContainerOptions], /) -> typing.Optional[winsdk.windows.foundation.collections.IVector[SharedPackageContainer]]: ...
    def get_container(self, id: str, /) -> typing.Optional[SharedPackageContainer]: ...
    @staticmethod
    def get_default() -> typing.Optional[SharedPackageContainerManager]: ...
    @staticmethod
    def get_for_provisioning() -> typing.Optional[SharedPackageContainerManager]: ...
    @staticmethod
    def get_for_user(user_sid: str, /) -> typing.Optional[SharedPackageContainerManager]: ...

class SharedPackageContainerMember(winsdk.system.Object):
    package_family_name: str
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> SharedPackageContainerMember: ...
    def __new__(cls: typing.Type[SharedPackageContainerMember], package_family_name: str) -> SharedPackageContainerMember:...

class StagePackageOptions(winsdk.system.Object):
    target_volume: typing.Optional[PackageVolume]
    stub_package_option: StubPackageOption
    stage_in_place: winsdk.system.Boolean
    required_content_group_only: winsdk.system.Boolean
    install_all_resources: winsdk.system.Boolean
    force_update_from_any_version: winsdk.system.Boolean
    external_location_uri: typing.Optional[winsdk.windows.foundation.Uri]
    developer_mode: winsdk.system.Boolean
    allow_unsigned: winsdk.system.Boolean
    dependency_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    optional_package_family_names: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    optional_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    related_package_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    expected_digests: typing.Optional[winsdk.windows.foundation.collections.IMap[winsdk.windows.foundation.Uri, str]]
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> StagePackageOptions: ...
    def __new__(cls: typing.Type[StagePackageOptions]) -> StagePackageOptions:...

class UpdateSharedPackageContainerOptions(winsdk.system.Object):
    require_packages_present: winsdk.system.Boolean
    force_app_shutdown: winsdk.system.Boolean
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> UpdateSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[UpdateSharedPackageContainerOptions]) -> UpdateSharedPackageContainerOptions:...

class UpdateSharedPackageContainerResult(winsdk.system.Object):
    extended_error: winsdk.windows.foundation.HResult
    status: SharedPackageContainerOperationStatus
    @staticmethod
    def _from(obj: winsdk.system.Object, /) -> UpdateSharedPackageContainerResult: ...

